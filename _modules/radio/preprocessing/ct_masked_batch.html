
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>radio.preprocessing.ct_masked_batch &#8212; RadIO 0.1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">RadIO 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for radio.preprocessing.ct_masked_batch</h1><div class="highlight"><pre>
<span></span><span class="c1"># pylint: disable=no-member</span>
<span class="c1"># pylint: disable=too-many-public-methods</span>
<span class="c1"># pylint: disable=too-many-locals</span>
<span class="c1"># pylint: disable=too-many-arguments</span>

<span class="sd">&quot;&quot;&quot; Batch class CTImagesMaskedBatch for storing CT-scans with masks. &quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">njit</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">measure</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm_notebook</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">tqdm_notebook</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

<span class="kn">from</span> <span class="nn">.ct_batch</span> <span class="k">import</span> <span class="n">CTImagesBatch</span>
<span class="kn">from</span> <span class="nn">.mask</span> <span class="k">import</span> <span class="n">make_mask_numba</span><span class="p">,</span> <span class="n">create_mask_reg</span>
<span class="kn">from</span> <span class="nn">.histo</span> <span class="k">import</span> <span class="n">sample_histo3d</span>
<span class="kn">from</span> <span class="nn">.crop</span> <span class="k">import</span> <span class="n">make_central_crop</span>
<span class="kn">from</span> <span class="nn">..dataset</span> <span class="k">import</span> <span class="n">action</span><span class="p">,</span> <span class="n">DatasetIndex</span><span class="p">,</span> <span class="n">SkipBatchException</span>  <span class="c1"># pylint: disable=no-name-in-module</span>


<span class="c1"># logger initialization</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span> <span class="c1"># pylint: disable=invalid-name</span>


<div class="viewcode-block" id="get_nodules_numba"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.get_nodules_numba">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_nodules_numba</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Fetch nodules from array by starting positions.</span>

<span class="sd">    Takes array with data of shape (z, y, x) from `batch`,</span>
<span class="sd">    ndarray(p, 3) with starting indices of nodules where p is number</span>
<span class="sd">    of nodules and size of type ndarray(3, ) which contains</span>
<span class="sd">    sizes of nodules along each axis. The output is 3d ndarray with nodules</span>
<span class="sd">    put in CTImagesBatch-compatible skyscraper structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        CTImagesBatch `skyscraper` represented by 3D ndarray.</span>
<span class="sd">    positions : ndarray(l, 3) of int</span>
<span class="sd">        Contains nodules&#39; starting indices along [zyx]-axis accordingly in `data`.</span>
<span class="sd">    size : ndarray(3,) of int</span>
<span class="sd">        Contains nodules&#39; sizes along each axis (z,y,x).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Dtypes of positions and size arrays must be the same.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        3d ndarray with nodules</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

    <span class="n">n_positions</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_positions</span><span class="p">):</span>
        <span class="n">out_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span> <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span> <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span> <span class="n">positions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">out_arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_positions</span> <span class="o">*</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="CTImagesMaskedBatch"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch">[docs]</a><span class="k">class</span> <span class="nc">CTImagesMaskedBatch</span><span class="p">(</span><span class="n">CTImagesBatch</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Batch class for storing batch of ct-scans with masks for nodules.</span>

<span class="sd">    Allows to load info about cancer nodules, then create cancer-masks</span>
<span class="sd">    for each patient. Created masks are stored in self.masks</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index : dataset.index</span>
<span class="sd">        ids of scans to be put in a batch</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    components : tuple of strings.</span>
<span class="sd">        List names of data components of a batch, which are `images`,</span>
<span class="sd">        `masks`, `origin` and `spacing`.</span>
<span class="sd">        NOTE: Implementation of this attribute is required by Base class.</span>
<span class="sd">    num_nodules : int</span>
<span class="sd">        number of nodules in batch</span>
<span class="sd">    images : ndarray</span>
<span class="sd">        contains ct-scans for all patients in batch.</span>
<span class="sd">    masks : ndarray</span>
<span class="sd">        contains masks for all patients in batch.</span>
<span class="sd">    nodules : np.recarray</span>
<span class="sd">        contains info on cancer nodules location.</span>
<span class="sd">        record array contains the following information about nodules:</span>
<span class="sd">          - self.nodules.nodule_center -- ndarray(num_nodules, 3) centers of</span>
<span class="sd">            nodules in world coords;</span>
<span class="sd">          - self.nodules.nodule_size -- ndarray(num_nodules, 3) sizes of</span>
<span class="sd">            nodules along z, y, x in world coord;</span>
<span class="sd">          - self.nodules.img_size -- ndarray(num_nodules, 3) sizes of images of</span>
<span class="sd">            patient data corresponding to nodules;</span>
<span class="sd">          - self.nodules.offset -- ndarray(num_nodules, 3) position of individual</span>
<span class="sd">            patient scan inside batch;</span>
<span class="sd">          - self.nodules.spacing -- ndarray(num_nodules, 3) of spacing attribute</span>
<span class="sd">            of patients which correspond to nodules;</span>
<span class="sd">          - self.nodules.origin -- ndarray(num_nodules, 3) of origin attribute</span>
<span class="sd">            of patients which correspond to nodules.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nodules_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;patient_pos&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                              <span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                              <span class="p">(</span><span class="s1">&#39;img_size&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                              <span class="p">(</span><span class="s1">&#39;nodule_center&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                              <span class="p">(</span><span class="s1">&#39;nodule_size&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                              <span class="p">(</span><span class="s1">&#39;spacing&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)),</span>
                              <span class="p">(</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))])</span>

    <span class="n">components</span> <span class="o">=</span> <span class="s2">&quot;images&quot;</span><span class="p">,</span> <span class="s2">&quot;masks&quot;</span><span class="p">,</span> <span class="s2">&quot;spacing&quot;</span><span class="p">,</span> <span class="s2">&quot;origin&quot;</span>

<div class="viewcode-block" id="CTImagesMaskedBatch.make_indices"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.make_indices">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">make_indices</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Generate list of batch indices of given `size`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : int</span>
<span class="sd">            size of list with indices</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of random indices</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; indices = CTImagesMaskedBatch.make_indices(20)</span>
<span class="sd">        &gt;&gt;&gt; indices</span>
<span class="sd">        array([&#39;3c3eb09b&#39;, &#39;5b192d1f&#39;, &#39;f28ddbb0&#39;, &#39;14460196&#39;, &#39;31a92510&#39;,</span>
<span class="sd">               &#39;3f324e44&#39;, &#39;066ccf28&#39;, &#39;5570938d&#39;, &#39;5d1fb8f6&#39;, &#39;539ea09c&#39;,</span>
<span class="sd">               &#39;68f9f235&#39;, &#39;8f7b0c49&#39;, &#39;c7903591&#39;, &#39;dc8e9504&#39;, &#39;54e9eebc&#39;,</span>
<span class="sd">               &#39;778abd5a&#39;, &#39;99691fc6&#39;, &#39;7da49e85&#39;, &#39;0f343345&#39;, &#39;876fb9e6&#39;], dtype=&#39;&lt;U8&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">CTImagesMaskedBatch</span><span class="o">.</span><span class="n">make_filename</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)])</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Execute Batch construction and init of basic attributes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : Dataset.Index class.</span>
<span class="sd">            Required indexing of objects (files).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="CTImagesMaskedBatch.nodules_to_df"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.nodules_to_df">[docs]</a>    <span class="k">def</span> <span class="nf">nodules_to_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodules</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert nodules_info ndarray into pandas dataframe.</span>

<span class="sd">        Pandas DataFrame will contain following columns:</span>
<span class="sd">        &#39;source_id&#39; - id of source element of batch;</span>
<span class="sd">        &#39;nodule_id&#39; - generated id for nodules;</span>
<span class="sd">        &#39;locZ&#39;, &#39;locY&#39;, &#39;locX&#39; - coordinates of nodules&#39; centers;</span>
<span class="sd">        &#39;diamZ&#39;, &#39;diamY&#39;, &#39;diamX&#39; - sizes of nodules along zyx axes;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodules : ndarray of type nodules_info</span>
<span class="sd">            nodules_info type is defined inside of CTImagesMaskedBatch class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            centers, ids and sizes of nodules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nodule_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source_id&#39;</span><span class="p">,</span> <span class="s1">&#39;locZ&#39;</span><span class="p">,</span> <span class="s1">&#39;locY&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;locX&#39;</span><span class="p">,</span> <span class="s1">&#39;diamZ&#39;</span><span class="p">,</span> <span class="s1">&#39;diamY&#39;</span><span class="p">,</span> <span class="s1">&#39;diamX&#39;</span><span class="p">]</span>

        <span class="n">nodule_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_indices</span><span class="p">(</span><span class="n">nodules</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;source_id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">],</span>
                             <span class="s1">&#39;nodule_id&#39;</span><span class="p">:</span> <span class="n">nodule_id</span><span class="p">,</span>
                             <span class="s1">&#39;locZ&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                             <span class="s1">&#39;locY&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                             <span class="s1">&#39;locX&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                             <span class="s1">&#39;diamZ&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                             <span class="s1">&#39;diamY&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                             <span class="s1">&#39;diamX&#39;</span><span class="p">:</span> <span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]},</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.get_pos"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.get_pos">[docs]</a>    <span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a positon of an item for a given index in data</span>
<span class="sd">        or in self.`component`.</span>

<span class="sd">        Fetch correct position inside batch for an item, looks for it</span>
<span class="sd">        in `data`, if provided, or in `component` in self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : None or ndarray</span>
<span class="sd">            data from which subsetting is done.</span>
<span class="sd">            If None, retrieve position from `component` of batch,</span>
<span class="sd">            if ndarray, returns index.</span>
<span class="sd">        component : str</span>
<span class="sd">            name of a component, f.ex. &#39;images&#39;.</span>
<span class="sd">            if component provided, data should be None.</span>
<span class="sd">        index : str or int</span>
<span class="sd">            index of an item to be looked for.</span>
<span class="sd">            may be key from dataset (str)</span>
<span class="sd">            or index inside batch (int).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Position of item</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is an overload of get_pos from base Batch-class,</span>
<span class="sd">        see corresponding docstring for detailed explanation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ind_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_verified_pos</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">component</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper_bounds</span><span class="p">[</span><span class="n">ind_pos</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ind_pos</span><span class="p">,</span> <span class="n">ind_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">index</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_nodules</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get number of nodules in CTImagesMaskedBatch.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of nodules in CTImagesMaskedBatch.</span>
<span class="sd">            if fetch_nodules_info method has not been called yet returns 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

<div class="viewcode-block" id="CTImagesMaskedBatch.fetch_nodules_info"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.fetch_nodules_info">[docs]</a>    <span class="nd">@action</span>
    <span class="k">def</span> <span class="nf">fetch_nodules_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodules</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nodules_records</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">images_loaded</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract nodules&#39; info from nodules into attribute self.nodules.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodules : pd.DataFrame</span>
<span class="sd">            contains:</span>
<span class="sd">             - &#39;seriesuid&#39;: index of patient or series.</span>
<span class="sd">             - &#39;coordZ&#39;,&#39;coordY&#39;,&#39;coordX&#39;: coordinates of nodules center.</span>
<span class="sd">             - &#39;diameter_mm&#39;: diameter, in mm.</span>
<span class="sd">        nodules_records : np.recarray</span>
<span class="sd">            if not None, should</span>
<span class="sd">            contain the same fields as describe in Note.</span>
<span class="sd">        update : bool</span>
<span class="sd">            if False, warning appears to remind that nodules info</span>
<span class="sd">            will be earased and recomputed.</span>
<span class="sd">        images_loaded : bool</span>
<span class="sd">            if True, i.e. `images` component is loaded,</span>
<span class="sd">            and image_size is used to compute</span>
<span class="sd">            correct nodules location inside `skyscraper`.</span>
<span class="sd">            If False, it doesn&#39;t update info of location</span>
<span class="sd">            inside `skyscraper`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        batch</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Run this action only after  :func:`~radio.CTImagesBatch.load`.</span>
<span class="sd">        The method fills in record array self.nodules that contains the following information about nodules:</span>
<span class="sd">                               - self.nodules.nodule_center -- ndarray(num_nodules, 3) centers of</span>
<span class="sd">                                 nodules in world coords;</span>
<span class="sd">                               - self.nodules.nodule_size -- ndarray(num_nodules, 3) sizes of</span>
<span class="sd">                                 nodules along z, y, x in world coord;</span>
<span class="sd">                               - self.nodules.img_size -- ndarray(num_nodules, 3) sizes of images of</span>
<span class="sd">                                 patient data corresponding to nodules;</span>
<span class="sd">                               - self.nodules.offset -- ndarray(num_nodules, 3) of biases of</span>
<span class="sd">                                 patients which correspond to nodules;</span>
<span class="sd">                               - self.nodules.spacing -- ndarray(num_nodules, 3) of spacinf attribute</span>
<span class="sd">                                 of patients which correspond to nodules;</span>
<span class="sd">                               - self.nodules.origin -- ndarray(num_nodules, 3) of origin attribute</span>
<span class="sd">                                 of patients which correspond to nodules.</span>
<span class="sd">                               - self.nodules.patient_pos -- ndarray(num_nodules, 1) refers to</span>
<span class="sd">                                 positions of patients which correspond to stored nodules.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">update</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Nodules have already been extracted. &quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;Put update argument as True for refreshing&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">nodules_records</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># load from record-array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="n">nodules_records</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># assume that nodules is supplied and load from it</span>
            <span class="n">required_columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;seriesuid&#39;</span><span class="p">,</span> <span class="s1">&#39;diameter_mm&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;coordZ&#39;</span><span class="p">,</span> <span class="s1">&#39;coordY&#39;</span><span class="p">,</span> <span class="s1">&#39;coordX&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">nodules</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">required_columns</span><span class="p">,</span> <span class="n">nodules</span><span class="o">.</span><span class="n">columns</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;Argument &#39;nodules&#39; must be pandas DataFrame&quot;</span>
                                  <span class="o">+</span> <span class="s2">&quot; with </span><span class="si">{}</span><span class="s2"> columns. Make sure that data provided&quot;</span>
                                  <span class="o">+</span> <span class="s2">&quot; in correct format.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">required_columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>

            <span class="n">nodules_df</span> <span class="o">=</span> <span class="n">nodules</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;seriesuid&#39;</span><span class="p">)</span>

            <span class="n">unique_indices</span> <span class="o">=</span> <span class="n">nodules_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="n">inter_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">unique_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">nodules_df</span> <span class="o">=</span> <span class="n">nodules_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inter_index</span><span class="p">,</span>
                                        <span class="p">[</span><span class="s2">&quot;coordZ&quot;</span><span class="p">,</span> <span class="s2">&quot;coordY&quot;</span><span class="p">,</span>
                                         <span class="s2">&quot;coordX&quot;</span><span class="p">,</span> <span class="s2">&quot;diameter_mm&quot;</span><span class="p">]]</span>

            <span class="n">num_nodules</span> <span class="o">=</span> <span class="n">nodules_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodules</span><span class="p">,</span>
                                                 <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules_dtype</span><span class="p">))</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pat_id</span><span class="p">,</span> <span class="n">coordz</span><span class="p">,</span> <span class="n">coordy</span><span class="p">,</span> <span class="n">coordx</span><span class="p">,</span> <span class="n">diam</span> <span class="ow">in</span> <span class="n">nodules_df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
                <span class="n">pat_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">pat_id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">pat_pos</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coordz</span><span class="p">,</span>
                                                                   <span class="n">coordy</span><span class="p">,</span>
                                                                   <span class="n">coordx</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">diam</span><span class="p">,</span> <span class="n">diam</span><span class="p">,</span> <span class="n">diam</span><span class="p">])</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_nodules_info</span><span class="p">(</span><span class="n">images_loaded</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.fetch_nodules_from_mask"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.fetch_nodules_from_mask">[docs]</a>    <span class="nd">@action</span>
    <span class="k">def</span> <span class="nf">fetch_nodules_from_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images_loaded</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fetch nodules info (centers and sizes) from masks.</span>

<span class="sd">        Runs skimage.measure.labels for fetching nodules regions</span>
<span class="sd">        from masks. Extracts nodules info from segmented regions</span>
<span class="sd">        and put this information in self.nodules np.recarray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        images_loaded : bool</span>
<span class="sd">            if True, i.e. `images` component is loaded,</span>
<span class="sd">            and image_size is used to compute</span>
<span class="sd">            correct nodules location inside `skyscraper`.</span>
<span class="sd">            If False, it doesn&#39;t update info of location</span>
<span class="sd">            inside `skyscraper`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        batch</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Sizes along [zyx] will be the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodules_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">)</span>
            <span class="n">mask_labels</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">props</span> <span class="ow">in</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">(</span><span class="n">mask_labels</span><span class="p">)):</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">props</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                     <span class="n">props</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">props</span><span class="o">.</span><span class="n">centroid</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">center</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

                <span class="n">diameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">props</span><span class="o">.</span><span class="n">equivalent_diameter</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
                <span class="n">nodules_list</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;patient_pos&#39;</span><span class="p">:</span> <span class="n">pos</span><span class="p">,</span>
                                     <span class="s1">&#39;nodule_center&#39;</span><span class="p">:</span> <span class="n">center</span><span class="p">,</span>
                                     <span class="s1">&#39;nodule_size&#39;</span><span class="p">:</span> <span class="n">diameter</span><span class="p">})</span>

        <span class="n">num_nodules</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodules_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_nodules</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules_dtype</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nodule</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodules_list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodule</span><span class="p">[</span><span class="s1">&#39;patient_pos&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nodule</span><span class="p">[</span><span class="s1">&#39;nodule_center&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nodule</span><span class="p">[</span><span class="s1">&#39;nodule_size&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_nodules_info</span><span class="p">(</span><span class="n">images_loaded</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="c1"># TODO: another name of method</span>
    <span class="k">def</span> <span class="nf">_fit_into_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Fetch start voxel coordinates of all nodules.</span>

<span class="sd">        Get start voxel coordinates of all nodules in batch.</span>
<span class="sd">        Note that all nodules are considered to have</span>
<span class="sd">        fixed same size defined by argument size: if nodule is out of</span>
<span class="sd">        patient&#39;s 3d image bounds than it&#39;s center is shifted to border.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : list or tuple of ndarrays</span>
<span class="sd">            ndarray(3, ) with diameters of nodules in (z,y,x).</span>
<span class="sd">        variance : ndarray(3, )</span>
<span class="sd">            diagonal elements of multivariate normal distribution,</span>
<span class="sd">            for sampling random shifts along (z,y,x) correspondingly.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            start coordinates (z,y,x) of all nodules in batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">center_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">-</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span>
        <span class="n">start_pix</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">center_pix</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_pix</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                                                       <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">variance</span><span class="p">),</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">end_pix</span> <span class="o">=</span> <span class="n">start_pix</span> <span class="o">+</span> <span class="n">size</span>

        <span class="n">bias_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">end_pix</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">img_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">start_pix</span> <span class="o">-=</span> <span class="n">bias_upper</span>
        <span class="n">end_pix</span> <span class="o">-=</span> <span class="n">bias_upper</span>

        <span class="n">bias_lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="n">start_pix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">start_pix</span> <span class="o">+=</span> <span class="n">bias_lower</span>
        <span class="n">end_pix</span> <span class="o">+=</span> <span class="n">bias_lower</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">start_pix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

<div class="viewcode-block" id="CTImagesMaskedBatch.create_mask"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.create_mask">[docs]</a>    <span class="nd">@action</span>
    <span class="k">def</span> <span class="nf">create_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create `masks` component from `nodules` component.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        `nodules` must be not None before calling this method.</span>
<span class="sd">        see :func:`~radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.fetch_nodules_info`</span>
<span class="sd">        for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Info about nodules location must &quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;be loaded before calling this method. &quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;Nothing happened.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>

        <span class="n">center_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">-</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span>
        <span class="n">start_pix</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_pix</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">start_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">start_pix</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">make_mask_numba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">img_size</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">start_pix</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.fetch_mask"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.fetch_mask">[docs]</a>    <span class="k">def</span> <span class="nf">fetch_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create `masks` component of different size then `images`,</span>
<span class="sd">        using `nodules` component.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple, list or ndarray of int.</span>
<span class="sd">            (z_dim,y_dim,x_dim), shape of mask to be created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            3d array with masks in form of `skyscraper`.</span>

<span class="sd">        # TODO: one part of code from here repeats create_mask function</span>
<span class="sd">            better to unify these two func</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Info about nodules location must &quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;be loaded before calling this method. &quot;</span> <span class="o">+</span>
                           <span class="s2">&quot;Nothing happened.&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="c1"># infer scale factor; assume patients are already resized to equal</span>
        <span class="c1"># shapes</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># get rescaled nodule-centers, nodule-sizes, offsets, locs of nod</span>
        <span class="c1"># starts</span>
        <span class="n">center_scaled</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">)</span>
        <span class="n">start_scaled</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_scaled</span> <span class="o">-</span> <span class="n">scale_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">start_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">start_scaled</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">offset_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">offset</span> <span class="o">*</span>
                                <span class="n">scale_factor</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">img_size_scaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">img_size</span> <span class="o">*</span> <span class="n">scale_factor</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">nod_size_scaled</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">scale_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="c1"># put nodules into mask</span>
        <span class="n">make_mask_numba</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">offset_scaled</span><span class="p">,</span> <span class="n">img_size_scaled</span> <span class="o">+</span> <span class="n">offset_scaled</span><span class="p">,</span>
                        <span class="n">start_scaled</span><span class="p">,</span> <span class="n">nod_size_scaled</span><span class="p">)</span>
        <span class="c1"># return ndarray-mask</span>
        <span class="k">return</span> <span class="n">mask</span></div>

    <span class="c1"># TODO rename function to sample_random_nodules_positions</span>
<div class="viewcode-block" id="CTImagesMaskedBatch.sample_random_nodules"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.sample_random_nodules">[docs]</a>    <span class="k">def</span> <span class="nf">sample_random_nodules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_nodules</span><span class="p">,</span> <span class="n">nodule_size</span><span class="p">,</span> <span class="n">histo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sample random nodules positions in CTImagesBatchMasked.</span>

<span class="sd">        Samples random nodules positions in ndarray. Each nodule have shape</span>
<span class="sd">        defined by `nodule_size`. If size of patients&#39; data along z-axis</span>
<span class="sd">        is not the same for different patients, NotImplementedError will be raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_nodules : int</span>
<span class="sd">            number of nodules to sample from dataset.</span>
<span class="sd">        nodule_size : ndarray(3, )</span>
<span class="sd">            crop shape along (z,y,x).</span>
<span class="sd">        histo : tuple</span>
<span class="sd">            np.histogram()&#39;s output.</span>
<span class="sd">            3d-histogram, represented by tuple (bins, edges).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            ndarray(num_nodules, 3). 1st array&#39;s dim is an index of sampled</span>
<span class="sd">            nodules, 2nd points out start positions (integers) of nodules</span>
<span class="sd">            in batch `skyscraper`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">sampled_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
            <span class="n">all_indices</span><span class="p">,</span> <span class="n">num_nodules</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_nodules</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">offset</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span><span class="n">sampled_indices</span><span class="p">]</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="n">sampled_indices</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># if supplied, use histogram as the sampler</span>
        <span class="k">if</span> <span class="n">histo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">size</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">size</span><span class="p">:</span> <span class="n">sample_histo3d</span><span class="p">(</span><span class="n">histo</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">num_nodules</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">data_shape</span> <span class="o">-</span> <span class="n">nodule_size</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">histo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">/=</span> <span class="n">data_shape</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">samples</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="n">sampled_indices</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.sample_nodules"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.sample_nodules">[docs]</a>    <span class="nd">@action</span>
    <span class="k">def</span> <span class="nf">sample_nodules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">nodule_size</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">share</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>        <span class="c1"># pylint: disable=too-many-locals, too-many-statements</span>
                       <span class="n">mask_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">histo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sample random crops of `images` and `masks` from batch.</span>

<span class="sd">        Create random crops, both with and without nodules in it, from input batch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            number of nodules in the output batch. Required,</span>
<span class="sd">            if share=0.0. If None, resulting batch will include all</span>
<span class="sd">            cancerous nodules.</span>
<span class="sd">        nodule_size : tuple, list or ndarray of int</span>
<span class="sd">            crop shape along (z,y,x).</span>
<span class="sd">        share : float</span>
<span class="sd">            share of cancer crops in the batch.</span>
<span class="sd">            if input CTImagesBatch contains less cancer</span>
<span class="sd">            nodules than needed random nodules will be taken.</span>
<span class="sd">        variance : tuple, list or ndarray of float</span>
<span class="sd">            variances of normally distributed random shifts of</span>
<span class="sd">            nodules&#39; start positions.</span>
<span class="sd">        mask_shape : tuple, list or ndarray of int</span>
<span class="sd">            size of `masks` crop in (z,y,x)-order. If not None,</span>
<span class="sd">            crops with masks would be of mask_shape.</span>
<span class="sd">            If None, mask crop shape would be equal to crop_size.</span>
<span class="sd">        histo : tuple</span>
<span class="sd">            np.histogram()&#39;s output.</span>
<span class="sd">            Used for sampling non-cancerous crops.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Batch</span>
<span class="sd">            batch with cancerous and non-cancerous crops in a proportion defined by</span>
<span class="sd">            `share` with total `batch_size` nodules. If `share` == 1.0, `batch_size`</span>
<span class="sd">            is None, resulting batch consists of all cancerous crops stored in batch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure that nodules&#39; info is fetched and args are OK</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Info about nodules location must &quot;</span> <span class="o">+</span>
                                 <span class="s2">&quot;be loaded before calling this method&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">variance</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Argument variance be np.array-like&#39;</span> <span class="o">+</span>
                               <span class="s1">&#39;and has shape (3,). &#39;</span> <span class="o">+</span>
                               <span class="s1">&#39;Would be used no-scale-shift.&#39;</span><span class="p">)</span>
                <span class="n">variance</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">share</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either supply batch_size or set share to positive number&#39;</span><span class="p">)</span>

        <span class="c1"># pos of batch-items that correspond to crops</span>
        <span class="n">crops_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

        <span class="c1"># infer the number of cancerous nodules and the size of batch</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span> <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">share</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodules</span>
        <span class="n">cancer_n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">share</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">cancer_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodules</span> <span class="k">if</span> <span class="n">cancer_n</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodules</span> <span class="k">else</span> <span class="n">cancer_n</span>

        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SkipBatchException</span><span class="p">(</span><span class="s1">&#39;Batch of zero size cannot be passed further through the workflow&#39;</span><span class="p">)</span>

        <span class="c1"># choose cancerous nodules&#39; starting positions</span>
        <span class="n">nodule_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nodule_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodules</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cancer_nodules</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># adjust cancer nodules&#39; starting positions s.t. nodules fit into</span>
            <span class="c1"># scan-boxes</span>
            <span class="n">cancer_nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_into_bounds</span><span class="p">(</span>
                <span class="n">nodule_size</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="n">variance</span><span class="p">)</span>

            <span class="c1"># randomly select needed number of cancer nodules (their starting</span>
            <span class="c1"># positions)</span>
            <span class="n">sample_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodules</span><span class="p">),</span>
                                              <span class="n">size</span><span class="o">=</span><span class="n">cancer_n</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">cancer_nodules</span> <span class="o">=</span> <span class="n">cancer_nodules</span><span class="p">[</span><span class="n">sample_indices</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># store scans-indices for chosen crops</span>
            <span class="n">cancerous_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">[</span><span class="n">sample_indices</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">crops_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">crops_indices</span><span class="p">,</span> <span class="n">cancerous_indices</span><span class="p">])</span>

        <span class="n">nodules_st_pos</span> <span class="o">=</span> <span class="n">cancer_nodules</span>

        <span class="c1"># if non-cancerous nodules are needed, add random starting pos</span>
        <span class="k">if</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="n">cancer_n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># sample starting positions for (most-likely) non-cancerous crops</span>
            <span class="n">random_nodules</span><span class="p">,</span> <span class="n">random_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_random_nodules</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">-</span> <span class="n">cancer_n</span><span class="p">,</span>
                                                                        <span class="n">nodule_size</span><span class="p">,</span> <span class="n">histo</span><span class="o">=</span><span class="n">histo</span><span class="p">)</span>

            <span class="c1"># concat non-cancerous and cancerous crops&#39; starting positions</span>
            <span class="n">nodules_st_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">nodules_st_pos</span><span class="p">,</span> <span class="n">random_nodules</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>

            <span class="c1"># store scan-indices for randomly chose crops</span>
            <span class="n">crops_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">crops_indices</span><span class="p">,</span> <span class="n">random_indices</span><span class="p">])</span>

        <span class="c1"># obtain nodules&#39; scans by cropping from self.images</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">get_nodules_numba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">,</span> <span class="n">nodules_st_pos</span><span class="p">,</span> <span class="n">nodule_size</span><span class="p">)</span>

        <span class="c1"># if mask_shape not None, compute scaled mask for the whole batch</span>
        <span class="c1"># scale also nodules&#39; starting positions and nodules&#39; shapes</span>
        <span class="k">if</span> <span class="n">mask_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask_shape</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nodule_size</span><span class="p">)</span>
            <span class="n">batch_mask_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
                <span class="n">scale_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">batch_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch_mask</span><span class="p">(</span><span class="n">batch_mask_shape</span><span class="p">)</span>
            <span class="n">nodules_st_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
                <span class="n">scale_factor</span> <span class="o">*</span> <span class="n">nodules_st_pos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">batch_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span>
            <span class="n">mask_shape</span> <span class="o">=</span> <span class="n">nodule_size</span>

        <span class="c1"># crop nodules&#39; masks</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="n">get_nodules_numba</span><span class="p">(</span><span class="n">batch_mask</span><span class="p">,</span> <span class="n">nodules_st_pos</span><span class="p">,</span> <span class="n">mask_shape</span><span class="p">)</span>

        <span class="c1"># build nodules&#39; batch</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">nodule_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">crops_spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="n">crops_indices</span><span class="p">]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">offset</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span><span class="n">crops_indices</span><span class="p">]</span>
        <span class="n">crops_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="n">crops_indices</span><span class="p">]</span> <span class="o">+</span> <span class="n">crops_spacing</span> <span class="o">*</span> <span class="p">(</span><span class="n">nodules_st_pos</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
        <span class="n">names_gen</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">crops_indices</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_indices</span><span class="p">(</span><span class="n">batch_size</span><span class="p">))</span>
        <span class="n">ix_batch</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">prefix</span><span class="p">,</span> <span class="n">random_str</span><span class="p">])</span> <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">random_str</span> <span class="ow">in</span> <span class="n">names_gen</span><span class="p">]</span>
        <span class="n">nodules_batch</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">DatasetIndex</span><span class="p">(</span><span class="n">ix_batch</span><span class="p">))</span>
        <span class="n">nodules_batch</span><span class="o">.</span><span class="n">_init_data</span><span class="p">(</span><span class="n">images</span><span class="o">=</span><span class="n">images</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">crops_spacing</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">crops_origin</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="n">masks</span><span class="p">)</span>  <span class="c1"># pylint: disable=protected-access</span>

        <span class="c1"># set nodules info in nodules&#39; batch</span>
        <span class="n">nodules_records</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span> <span class="o">==</span> <span class="n">crop_pos</span><span class="p">]</span> <span class="k">for</span> <span class="n">crop_pos</span> <span class="ow">in</span> <span class="n">crops_indices</span><span class="p">]</span>
        <span class="n">new_patient_pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">records</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodules_records</span><span class="p">):</span>
            <span class="n">new_patient_pos</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>
        <span class="n">new_patient_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_patient_pos</span><span class="p">)</span>
        <span class="n">nodules_records</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">nodules_records</span><span class="p">)</span>
        <span class="n">nodules_records</span> <span class="o">=</span> <span class="n">nodules_records</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="n">nodules_records</span><span class="o">.</span><span class="n">patient_pos</span> <span class="o">=</span> <span class="n">new_patient_pos</span>
        <span class="n">nodules_batch</span><span class="o">.</span><span class="n">fetch_nodules_info</span><span class="p">(</span><span class="n">nodules_records</span><span class="o">=</span><span class="n">nodules_records</span><span class="p">)</span>

        <span class="c1"># leave out nodules with zero-intersection with crops&#39; boxes</span>
        <span class="n">nodules_batch</span><span class="o">.</span><span class="n">_filter_nodules_info</span><span class="p">()</span>                                                     <span class="c1"># pylint: disable=protected-access</span>

        <span class="k">return</span> <span class="n">nodules_batch</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.sample_dump"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.sample_dump">[docs]</a>    <span class="nd">@action</span>
    <span class="k">def</span> <span class="nf">sample_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">n_iters</span><span class="p">,</span> <span class="n">nodule_size</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">share</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform sample_nodules and dump on the same batch n_iters times.</span>

<span class="sd">        Can be used for fast creation of large datasets of cancerous/non-cancerous crops.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dst : str</span>
<span class="sd">            folder to dump nodules in.</span>
<span class="sd">        n_iters : int</span>
<span class="sd">            number of iterations to be performed.</span>
<span class="sd">        nodule_size : tuple, list or ndarray of int</span>
<span class="sd">            (z,y,x)-shape of sampled nodules.</span>
<span class="sd">        batch_size : int or None</span>
<span class="sd">            size of generated batches.</span>
<span class="sd">        share : float</span>
<span class="sd">            share of cancer nodules. See docstring of sample_nodules for more info</span>
<span class="sd">            about possible combinations of parameters share and batch_size.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            additional arguments supplied into sample_nodules. See docstring</span>
<span class="sd">            of sample_nodules for more info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iters</span><span class="p">):</span>
            <span class="n">nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_nodules</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">nodule_size</span><span class="o">=</span><span class="n">nodule_size</span><span class="p">,</span> <span class="n">share</span><span class="o">=</span><span class="n">share</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">nodules</span> <span class="o">=</span> <span class="n">nodules</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="n">dst</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.update_nodules_histo"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.update_nodules_histo">[docs]</a>    <span class="nd">@action</span>
    <span class="k">def</span> <span class="nf">update_nodules_histo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">histo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Update histogram of nodules&#39; locations using nodules locations from batch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        histo : list</span>
<span class="sd">            list(np.histogram()), used for sampling cancerous locations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Execute action only after .fetch_nodules_info().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># infer bins&#39; bounds from histo</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">histo</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># get cancer_nodules&#39; centers in voxel coords</span>
        <span class="n">center_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">-</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span>

        <span class="c1"># update bins of histo</span>
        <span class="n">histo_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">center_pix</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
        <span class="n">histo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">histo_delta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.get_axial_slice"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.get_axial_slice">[docs]</a>    <span class="k">def</span> <span class="nf">get_axial_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patient_pos</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get tuple of `images` slice and `masks` slice by patient and slice position.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        patient_pos : int</span>
<span class="sd">            patient position in the batch</span>
<span class="sd">        height : float</span>
<span class="sd">            number of slice (z-axis), scaled to [0:1]</span>
<span class="sd">            used to get slice with position:</span>
<span class="sd">            int(height * number_of slices_for_patient) from</span>
<span class="sd">            patient&#39;s scan and mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            (images_slice,masks_slice) by patient_pos and number of slice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">margin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">height</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">patient_pos</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">patient_pos</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">)[</span><span class="n">margin</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">patient_pos</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">)[</span><span class="n">margin</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">patient_pos</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">)[</span><span class="n">margin</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">patch</span></div>

    <span class="k">def</span> <span class="nf">_refresh_nodules_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images_loaded</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Refresh self.nodules attributes [spacing, origin, img_size, bias].</span>

<span class="sd">        This method is called to update [spacing, origin, img_size, bias]</span>
<span class="sd">        attributes of self.nodules because batch&#39;s inner data has changed,</span>
<span class="sd">        e.g. after resize.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        images_loaded : bool</span>
<span class="sd">            if True, assumes that `_bounds` attribute is computed,</span>
<span class="sd">            i.e. either `masks` and/or `images` are loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">images_loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">offset</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_bounds</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">img_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">def</span> <span class="nf">_filter_nodules_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Filter record-array self.nodules s.t. only records about cancerous nodules</span>
<span class="sd">        that have non-zero intersection with scan-boxes be present.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        can be called only after execution of fetch_nodules_info and _refresh_nodules_info</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># nodules start and trailing pixel-coords</span>
        <span class="n">center_pix</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span>
        <span class="n">start_pix</span> <span class="o">=</span> <span class="n">center_pix</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">start_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">start_pix</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">end_pix</span> <span class="o">=</span> <span class="n">start_pix</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span><span class="p">)</span>

        <span class="c1"># find nodules with no intersection with scan-boxes</span>
        <span class="n">nods_images_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span><span class="p">]</span>
        <span class="n">start_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">start_pix</span> <span class="o">&gt;=</span> <span class="n">nods_images_shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">end_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">end_pix</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">zero_mask</span> <span class="o">=</span> <span class="n">start_mask</span> <span class="o">|</span> <span class="n">end_mask</span>

        <span class="c1"># filter out such nodules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="p">[</span><span class="o">~</span><span class="n">zero_mask</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_rescale_spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Rescale spacing values and call _refresh_nodules_info().</span>

<span class="sd">        Method is called after any operation that changes shape of inner data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_nodules_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_post_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_of_arrs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Concatenate outputs of different workers and put the result in `masks`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        list_of_arrs : list</span>
<span class="sd">            list of ndarrays of patients&#39; masks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reraise_worker_exceptions</span><span class="p">(</span><span class="n">list_of_arrs</span><span class="p">)</span>
        <span class="n">new_masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">list_of_arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="n">new_masks</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_init_load_blosc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Init-func for load from blosc.</span>

<span class="sd">        Fills images/masks-components with zeroes if the components are to be updated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">                components : str, list or tuple</span>
<span class="sd">                    iterable of components names that need to be loaded</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of ids of batch-items, i.e. series ids or patient ids.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># fill &#39;images&#39;, &#39;masks&#39;-comps with zeroes if needed</span>
        <span class="n">skysc_components</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">}</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;components&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prealloc_skyscraper_components</span><span class="p">(</span><span class="n">skysc_components</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>

    <span class="k">def</span> <span class="nf">_post_rebuild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_outputs</span><span class="p">,</span> <span class="n">new_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Gather outputs of different workers, rebuild `images` and `masks`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        all_outputs : list</span>
<span class="sd">            list of outputs. Each item is given by tuple.</span>
<span class="sd">        new_batch : bool</span>
<span class="sd">            if True, returns new batch with data agregated</span>
<span class="sd">            from all_ouputs. if False, changes self.</span>
<span class="sd">        **kwargs</span>
<span class="sd">                shape : list, tuple or ndarray of int</span>
<span class="sd">                    (z,y,x)-shape of every image in image component after action is performed.</span>
<span class="sd">                spacing : tuple, list or ndarray of float</span>
<span class="sd">                    (z,y,x)-spacing for each image. If supplied, assume that</span>
<span class="sd">                    unify_spacing is performed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        batch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: process errors</span>
        <span class="n">batch</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_post_rebuild</span><span class="p">(</span><span class="n">all_outputs</span><span class="p">,</span> <span class="n">new_batch</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">batch</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span>
        <span class="n">batch</span><span class="o">.</span><span class="n">_rescale_spacing</span><span class="p">()</span>  <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch</span><span class="o">.</span><span class="n">create_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">batch</span>

<div class="viewcode-block" id="CTImagesMaskedBatch.make_xip"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.make_xip">[docs]</a>    <span class="nd">@action</span>
    <span class="k">def</span> <span class="nf">make_xip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;axial&#39;</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Make intensity projection (maximum, minimum, mean or median).</span>

<span class="sd">        Notice that axis is chosen according to projection argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        depth : int</span>
<span class="sd">            number of slices over which xip operation is performed.</span>
<span class="sd">        stride : int</span>
<span class="sd">            stride-step along projection dimension.</span>
<span class="sd">        mode : str</span>
<span class="sd">            Possible values are &#39;max&#39;, &#39;min&#39;, &#39;mean&#39; or &#39;median&#39;.</span>
<span class="sd">        projection : str</span>
<span class="sd">            Possible values: &#39;axial&#39;, &#39;coronal&#39;, &#39;sagital&#39;.</span>
<span class="sd">            In case of &#39;coronal&#39; and &#39;sagital&#39; projections tensor</span>
<span class="sd">            will be transposed from [z,y,x] to [x,z,y] and [y,z,x].</span>
<span class="sd">        padding : str</span>
<span class="sd">            mode of padding that will be passed in numpy.padding function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;axial&#39;</span><span class="p">:</span>
            <span class="n">_projection</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;coronal&#39;</span><span class="p">:</span>
            <span class="n">_projection</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">projection</span> <span class="o">==</span> <span class="s1">&#39;sagital&#39;</span><span class="p">:</span>
            <span class="n">_projection</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="n">batch</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">make_xip</span><span class="p">(</span><span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                                 <span class="n">projection</span><span class="o">=</span><span class="n">projection</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">projection_spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">spacing</span><span class="p">[:,</span> <span class="n">_projection</span><span class="p">]</span>
            <span class="n">batch</span><span class="o">.</span><span class="n">nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span>
            <span class="n">batch</span><span class="o">.</span><span class="n">nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="p">[:,</span> <span class="n">_projection</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">depth</span> <span class="o">*</span> <span class="n">projection_spacing</span><span class="p">)</span>  <span class="c1"># pylint: disable=unsubscriptable-object</span>
        <span class="n">batch</span><span class="o">.</span><span class="n">_rescale_spacing</span><span class="p">()</span>   <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch</span><span class="o">.</span><span class="n">create_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">batch</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.central_crop"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.central_crop">[docs]</a>    <span class="nd">@action</span>
    <span class="k">def</span> <span class="nf">central_crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">,</span> <span class="n">crop_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Make crop of crop_size from center of images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crop_size : tuple, list or ndarray of int</span>
<span class="sd">            (z,y,x)-shape of central crop along three axes(z,y,x order is used).</span>
<span class="sd">        crop_mask : bool</span>
<span class="sd">            if True, crop the mask in the same way.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        batch</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crop_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">crop_size</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">crop_halfsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">crop_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">img_shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">shape</span> <span class="o">&lt;</span> <span class="n">crop_size</span><span class="p">)</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">img_shapes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Crop size must be smaller than size of inner 3D images&quot;</span><span class="p">)</span>

        <span class="n">cropped_images</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cropped_masks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;images&#39;</span><span class="p">)</span>
            <span class="n">cropped_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">make_central_crop</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">crop_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">)</span>
                <span class="n">cropped_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">make_central_crop</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">crop_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">cropped_images</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">crop_mask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">cropped_masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># recalculate origin, refresh nodules_info, leave only relevant nodules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">*</span> <span class="n">crop_halfsize</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refresh_nodules_info</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filter_nodules_info</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.flip"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.flip">[docs]</a>    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="sd">&quot;&quot;&quot; Invert the order of slices for each patient</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        batch</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; batch = batch.flip()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;There is no implementation of flip method for class &quot;</span> <span class="o">+</span>
                       <span class="s2">&quot;CTIMagesMaskedBatch. Nothing happened&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.binarize_mask"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.binarize_mask">[docs]</a>    <span class="nd">@action</span>
    <span class="k">def</span> <span class="nf">binarize_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.35</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Binarize masks by threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : float</span>
<span class="sd">            threshold for masks binarization.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masks</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.predict_on_scan"><a class="viewcode-back" href="../../../api/masked_batch.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.predict_on_scan">[docs]</a>    <span class="nd">@action</span>
    <span class="k">def</span> <span class="nf">predict_on_scan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">crop_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
                        <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">targets_mode</span><span class="o">=</span><span class="s1">&#39;segmentation&#39;</span><span class="p">,</span> <span class="n">data_format</span><span class="o">=</span><span class="s1">&#39;channels_last&#39;</span><span class="p">,</span>
                        <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="s1">&#39;tf&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get predictions of the model on data contained in batch.</span>

<span class="sd">        Transforms scan data into patches of shape CROP_SHAPE and then feed</span>
<span class="sd">        this patches sequentially into model with name specified by</span>
<span class="sd">        argument &#39;model_name&#39;; after that loads predicted masks or probabilities</span>
<span class="sd">        into &#39;masks&#39; component of the current batch and returns it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_name : str</span>
<span class="sd">            name of model that will be used for predictions.</span>
<span class="sd">        strides : tuple, list or ndarray of int</span>
<span class="sd">            (z,y,x)-strides for patching operation.</span>
<span class="sd">        crop_shape : tuple, list or ndarray of int</span>
<span class="sd">            (z,y,x)-shape of crops.</span>
<span class="sd">        batch_size : int</span>
<span class="sd">            number of patches to feed in model in one iteration.</span>
<span class="sd">        targets_mode: str</span>
<span class="sd">            type of targets &#39;segmentation&#39;, &#39;regression&#39; or &#39;classification&#39;.</span>
<span class="sd">        data_format: str</span>
<span class="sd">            format of neural network input data,</span>
<span class="sd">            can be &#39;channels_first&#39; or &#39;channels_last&#39;.</span>
<span class="sd">        model_type : str</span>
<span class="sd">            represents type of model that will be used for prediction.</span>
<span class="sd">            Possible values are &#39;keras&#39; or &#39;tf&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        CTImagesMaskedBatch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_model_by_name</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
        <span class="n">crop_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">crop_shape</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">strides</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">patches_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_patches</span><span class="p">(</span><span class="n">patch_shape</span><span class="o">=</span><span class="n">crop_shape</span><span class="p">,</span>
                                       <span class="n">stride</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
                                       <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;channels_first&#39;</span><span class="p">:</span>
            <span class="n">patches_arr</span> <span class="o">=</span> <span class="n">patches_arr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;channels_last&#39;</span><span class="p">:</span>
            <span class="n">patches_arr</span> <span class="o">=</span> <span class="n">patches_arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">predictions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">iterations</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">patches_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">batch_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="n">iterations</span> <span class="o">=</span> <span class="n">tqdm_notebook</span><span class="p">(</span><span class="n">iterations</span><span class="p">)</span>  <span class="c1"># pylint: disable=redefined-variable-type</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s1">&#39;tf&#39;</span><span class="p">:</span>
                <span class="n">_prediction</span> <span class="o">=</span> <span class="n">_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;images&#39;</span><span class="p">:</span> <span class="n">patches_arr</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">,</span> <span class="o">...</span><span class="p">]})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_prediction</span> <span class="o">=</span> <span class="n">_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">patches_arr</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>

            <span class="n">current_prediction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">_prediction</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">targets_mode</span> <span class="o">==</span> <span class="s1">&#39;classification&#39;</span><span class="p">:</span>
                <span class="n">current_prediction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">crop_shape</span><span class="p">))</span> <span class="o">*</span> <span class="n">prob</span>
                                               <span class="k">for</span> <span class="n">prob</span> <span class="ow">in</span> <span class="n">current_prediction</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>

            <span class="k">if</span> <span class="n">targets_mode</span> <span class="o">==</span> <span class="s1">&#39;regression&#39;</span><span class="p">:</span>
                <span class="n">current_prediction</span> <span class="o">=</span> <span class="n">create_mask_reg</span><span class="p">(</span><span class="n">current_prediction</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span>
                                                     <span class="n">current_prediction</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">],</span>
                                                     <span class="n">current_prediction</span><span class="p">[:,</span> <span class="mi">6</span><span class="p">],</span>
                                                     <span class="n">crop_shape</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>

            <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_prediction</span><span class="p">)</span>

        <span class="n">patches_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">patches_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">patches_mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_from_patches</span><span class="p">(</span><span class="n">patches_mask</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
                               <span class="n">scan_shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]),</span>
                               <span class="n">data_attr</span><span class="o">=</span><span class="s1">&#39;masks&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.unpack"><a class="viewcode-back" href="../../../api/unpackers.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.unpack">[docs]</a>    <span class="k">def</span> <span class="nf">unpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="o">=</span><span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Basic way for unpacking components from batch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        component : str</span>
<span class="sd">            component to unpack, can be &#39;images&#39; or &#39;masks&#39;.</span>
<span class="sd">        data_format : str</span>
<span class="sd">            can be &#39;channels_last&#39; or &#39;channels_first&#39;. Reflects where to put</span>
<span class="sd">            channels dimension: right after batch dimension or after all spatial axes.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            key-word arguments that will be passed in callable if</span>
<span class="sd">            component argument reffers to method of batch class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray(batch_size, ...) or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">component</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">):</span>
            <span class="n">data_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;data_format&#39;</span><span class="p">,</span> <span class="s1">&#39;channels_last&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))])</span>

            <span class="k">if</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;channels_last&#39;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">data_format</span> <span class="o">==</span> <span class="s1">&#39;channels_first&#39;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attr_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">attr_value</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">attr_value</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">attr_value</span>
        <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.classification_targets"><a class="viewcode-back" href="../../../api/unpackers.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.classification_targets">[docs]</a>    <span class="k">def</span> <span class="nf">classification_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Unpack data from batch in format suitable for classification task.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : int</span>
<span class="sd">            minimum number of &#39;1&#39; pixels in mask to consider it cancerous.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray(batch_size, 1)</span>
<span class="sd">            targets for classification task: labels corresponding to cancerous</span>
<span class="sd">            nodules (&#39;1&#39;) and non-cancerous nodules (&#39;0&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">masks_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;masks&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">threshold</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masks_labels</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.regression_targets"><a class="viewcode-back" href="../../../api/unpackers.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.regression_targets">[docs]</a>    <span class="k">def</span> <span class="nf">regression_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Unpack data from batch in format suitable for regression task.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : int</span>
<span class="sd">            minimum number of &#39;1&#39; pixels in mask to consider it cancerous.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray(batch_size, 7)</span>
<span class="sd">            targets for regression task: cancer center, size</span>
<span class="sd">            and label(1 for cancerous and 0 for non-cancerous). Note that in case</span>
<span class="sd">            of non-cancerous crop first 6 column of output array will be set to zero.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodules</span>

        <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">item_pos</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">item_nodules</span> <span class="o">=</span> <span class="n">nodules</span><span class="p">[</span><span class="n">nodules</span><span class="o">.</span><span class="n">patient_pos</span> <span class="o">==</span> <span class="n">item_pos</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item_nodules</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">mask_nod_indices</span> <span class="o">=</span> <span class="n">item_nodules</span><span class="o">.</span><span class="n">nodule_size</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>

            <span class="n">nodule_sizes</span> <span class="o">=</span> <span class="p">(</span><span class="n">item_nodules</span><span class="o">.</span><span class="n">nodule_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="n">item_pos</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="n">item_pos</span><span class="p">,</span> <span class="p">:])</span>

            <span class="n">nodule_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">item_nodules</span><span class="o">.</span><span class="n">nodule_center</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span><span class="p">[</span><span class="n">item_pos</span><span class="p">,</span> <span class="p">:]</span>
                              <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">images_shape</span><span class="p">[</span><span class="n">item_pos</span><span class="p">,</span> <span class="p">:])</span>

            <span class="n">sizes</span><span class="p">[</span><span class="n">item_pos</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nodule_sizes</span><span class="p">[</span><span class="n">mask_nod_indices</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">centers</span><span class="p">[</span><span class="n">item_pos</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">nodule_centers</span><span class="p">[</span><span class="n">mask_nod_indices</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;classification_targets&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
        <span class="n">reg_targets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">centers</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">labels</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">reg_targets</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.segmentation_targets"><a class="viewcode-back" href="../../../api/unpackers.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.segmentation_targets">[docs]</a>    <span class="k">def</span> <span class="nf">segmentation_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_format</span><span class="o">=</span><span class="s1">&#39;channels_last&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Unpack data from batch in format suitable for regression task.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_format : str</span>
<span class="sd">            data_format shows where to put new axis for channels dimension:</span>
<span class="sd">            can be &#39;channels_last&#39; or &#39;channels_first&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray(batch_size, ...)</span>
<span class="sd">            batch array with masks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;masks&#39;</span><span class="p">,</span> <span class="n">data_format</span><span class="o">=</span><span class="n">data_format</span><span class="p">)</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.make_data_tf"><a class="viewcode-back" href="../../../api/unpackers.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.make_data_tf">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">make_data_tf</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;segmentation&#39;</span><span class="p">,</span> <span class="n">is_training</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Prepare data in batch for training neural network implemented in tensorflow.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : str</span>
<span class="sd">            mode can be one of following &#39;classification&#39;, &#39;regression&#39;</span>
<span class="sd">            or &#39;segmentation&#39;. Default is &#39;segmentation&#39;.</span>
<span class="sd">        data_format : str</span>
<span class="sd">            data format batch data. Can be &#39;channels_last&#39;</span>
<span class="sd">            or &#39;channels_first&#39;. Default is &#39;channels_last&#39;.</span>
<span class="sd">        is_training : bool</span>
<span class="sd">            whether model is in training or prediction mode. Default is True.</span>
<span class="sd">        threshold : int</span>
<span class="sd">            threshold value of &#39;1&#39; pixels in masks to consider it cancerous.</span>
<span class="sd">            Default is 10.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict or None</span>
<span class="sd">            feed dict and fetches for training neural network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;segmentation&#39;</span><span class="p">,</span> <span class="s1">&#39;classification&#39;</span><span class="p">,</span> <span class="s1">&#39;regression&#39;</span><span class="p">]:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">mode</span> <span class="o">+</span> <span class="s1">&#39;_targets&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument &#39;mode&#39; must have one of values: &quot;</span>
                             <span class="o">+</span> <span class="s2">&quot;&#39;segmentation&#39;, &#39;classification&#39; or &#39;regression&#39;&quot;</span><span class="p">)</span>

        <span class="n">feed_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">images</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_training</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">(</span><span class="n">images</span><span class="o">=</span><span class="n">inputs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">feed_dict</span><span class="o">=</span><span class="n">feed_dict</span><span class="p">,</span> <span class="n">fetches</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="CTImagesMaskedBatch.make_data_keras"><a class="viewcode-back" href="../../../api/unpackers.html#radio.preprocessing.ct_masked_batch.CTImagesMaskedBatch.make_data_keras">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">make_data_keras</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;segmentation&#39;</span><span class="p">,</span> <span class="n">is_training</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Prepare data in batch for training neural network implemented in keras.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : str</span>
<span class="sd">            mode can be one of following &#39;classification&#39;, &#39;regression&#39;</span>
<span class="sd">            or &#39;segmentation&#39;. Default is &#39;segmentation&#39;.</span>
<span class="sd">        data_format : str</span>
<span class="sd">            data format batch data. Can be &#39;channels_last&#39;</span>
<span class="sd">            or &#39;channels_first&#39;. Default is &#39;channels_last&#39;.</span>
<span class="sd">        is_training : bool</span>
<span class="sd">            whether model is in training or prediction mode. Default is True.</span>
<span class="sd">        threshold : int</span>
<span class="sd">            threshold value of &#39;1&#39; pixels in masks to consider it cancerous.</span>
<span class="sd">            Default is 10.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict or None</span>
<span class="sd">            kwargs for keras model train method:</span>
<span class="sd">            {&#39;x&#39;: ndarray(...), &#39;y&#39;: ndarrray(...)} for training neural network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;images&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;segmentation&#39;</span><span class="p">,</span> <span class="s1">&#39;classification&#39;</span><span class="p">,</span> <span class="s1">&#39;regression&#39;</span><span class="p">]:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">batch</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">mode</span> <span class="o">+</span> <span class="s1">&#39;_targets&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument &#39;mode&#39; must have one of values: &quot;</span>
                             <span class="o">+</span> <span class="s2">&quot;&#39;segmentation&#39;, &#39;classification&#39; or &#39;regression&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_training</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">inputs</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">RadIO 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, analysiscenter.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>